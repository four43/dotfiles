#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = ["click>=8.1"]
# ///
"""JIRA ticket CLI."""

import base64
import json
import os
import re
import sys
import tempfile
import time
import urllib.error
import urllib.parse
import urllib.request
from pathlib import Path

import click


# ── Config ──────────────────────────────────────────────


class Config:
    _DIR = Path(os.environ.get("XDG_CONFIG_HOME", Path.home() / ".config")) / "ticket"
    _FILE = _DIR / "config.json"
    _DEFAULTS = {
        "base_url": "https://vaisala.atlassian.net",
        "email": "${XWE_JIRA_EMAIL}",
        "api_token": "${XWE_JIRA_API_TOKEN}",
        "default_project": "WEAT",
        "projects": [],
        "team_groups": [],
    }
    _ENV_VAR_RE = re.compile(r"\$\{([^}]+)\}")

    def __init__(self):
        self._client: "JiraClient | None" = None

    def _expand(self, value: str) -> str:
        def replace(match: re.Match) -> str:
            var = match.group(1)
            val = os.environ.get(var)
            if val is None:
                raise click.ClickException(
                    f"Environment variable ${{{var}}} is not set "
                    f"(referenced in {self._FILE})"
                )
            return val
        return self._ENV_VAR_RE.sub(replace, value)

    def load(self) -> dict:
        """Load raw config (env vars NOT expanded)."""
        try:
            return json.loads(self._FILE.read_text())
        except FileNotFoundError:
            self.save(self._DEFAULTS)
            return dict(self._DEFAULTS)
        except json.JSONDecodeError:
            click.echo(f"Warning: corrupt config at {self._FILE}, using defaults", err=True)
            return dict(self._DEFAULTS)

    def resolve(self) -> dict:
        """Load config and expand all ${VAR} references."""
        raw = self.load()
        return {
            k: self._expand(v) if isinstance(v, str) else v
            for k, v in raw.items()
        }

    def save(self, updates: dict) -> None:
        """Merge updates into existing config and persist."""
        try:
            data = json.loads(self._FILE.read_text())
        except (FileNotFoundError, json.JSONDecodeError):
            data = dict(self._DEFAULTS)
        data.update(updates)
        self._DIR.mkdir(parents=True, exist_ok=True)
        self._FILE.write_text(json.dumps(data, indent=2) + "\n")

    def project(self, override: str | None = None) -> str:
        if override:
            return override
        raw = self.load()
        return raw.get("default_project", raw.get("last_project", "WEAT"))

    @property
    def base_url(self) -> str:
        return self.load().get("base_url", "https://vaisala.atlassian.net")

    @property
    def client(self) -> "JiraClient":
        if self._client is None:
            resolved = self.resolve()
            email = resolved.get("email", "")
            api_token = resolved.get("api_token", "")
            if not email or not api_token:
                raise click.ClickException(
                    "email and api_token must be configured in " + str(self._FILE)
                )
            self._client = JiraClient(
                resolved.get("base_url", "https://vaisala.atlassian.net"),
                email, api_token,
            )
        return self._client


config = Config()


# ── ADF (Atlassian Document Format) ────────────────────

def _adf_to_text(node: dict | None) -> str:
    """Convert an ADF document to plain text."""
    if not node:
        return ""
    ntype = node.get("type", "")
    children = node.get("content", [])

    if ntype == "text":
        return node.get("text", "")
    if ntype == "hardBreak":
        return "\n"
    if ntype == "rule":
        return "\n---\n"

    parts = [_adf_to_text(c) for c in children]
    text = "".join(parts)

    if ntype == "paragraph":
        return text + "\n\n"
    if ntype == "heading":
        level = node.get("attrs", {}).get("level", 1)
        return "#" * level + " " + text + "\n\n"
    if ntype == "bulletList":
        return text
    if ntype == "orderedList":
        return text
    if ntype == "listItem":
        lines = text.strip().split("\n")
        return "- " + "\n  ".join(lines) + "\n"
    if ntype == "blockquote":
        return "".join("> " + line + "\n" for line in text.strip().split("\n")) + "\n"
    if ntype == "codeBlock":
        lang = node.get("attrs", {}).get("language", "")
        return f"```{lang}\n{text}```\n\n"

    return text


def _text_to_adf(text: str) -> dict:
    """Convert plain text to a simple ADF document."""
    content = []
    for para in text.split("\n\n"):
        para = para.strip()
        if not para:
            continue
        inline: list[dict] = []
        lines = para.split("\n")
        for i, line in enumerate(lines):
            if i > 0:
                inline.append({"type": "hardBreak"})
            inline.append({"type": "text", "text": line})
        content.append({"type": "paragraph", "content": inline})
    return {"type": "doc", "version": 1, "content": content or [
        {"type": "paragraph", "content": []}
    ]}


EDIT_SEPARATOR = "──── description ────"


def _compose_edit_text(summary: str, description: str) -> str:
    """Build the text shown in the editor."""
    return f"{summary}\n{EDIT_SEPARATOR}\n{description}"


def _parse_edit_text(text: str) -> tuple[str, str]:
    """Parse editor text back into (summary, description)."""
    if EDIT_SEPARATOR in text:
        summary, _, description = text.partition(EDIT_SEPARATOR)
    else:
        summary, _, description = text.partition("\n")
    return summary.strip(), description.strip()


# ── Errors ──────────────────────────────────────────────


class JiraApiError(Exception):
    def __init__(self, status_code: int, body: dict):
        self.status_code = status_code
        self.body = body
        messages = body.get("errorMessages", [])
        errors = body.get("errors", {})
        if messages:
            detail = "; ".join(messages)
        elif errors:
            detail = "; ".join(f"{k}: {v}" for k, v in errors.items())
        else:
            detail = str(body)
        super().__init__(f"HTTP {status_code}: {detail}")


# ── JIRA Client ─────────────────────────────────────────


class JiraClient:
    def __init__(self, base_url: str, email: str, api_token: str):
        self.base_url = base_url.rstrip("/")
        self._auth_header = "Basic " + base64.b64encode(
            f"{email}:{api_token}".encode()
        ).decode()
        self._account_id: str | None = None

    @property
    def account_id(self) -> str:
        if self._account_id is None:
            me = self._get("/rest/api/3/myself")
            self._account_id = me["accountId"]
        return self._account_id

    # ── HTTP ────────────────────────────────────────────

    def _request(
        self,
        method: str,
        path: str,
        data: dict | None = None,
        params: dict | None = None,
    ) -> tuple[dict | None, int]:
        url = self.base_url + path
        if params:
            url += "?" + urllib.parse.urlencode(params, quote_via=urllib.parse.quote)

        body = json.dumps(data).encode() if data else None
        req = urllib.request.Request(url, data=body, method=method)
        req.add_header("Authorization", self._auth_header)
        req.add_header("Content-Type", "application/json")
        req.add_header("Accept", "application/json")

        try:
            resp = urllib.request.urlopen(req)
            status = resp.status
            resp_body = resp.read().decode()
            return (json.loads(resp_body) if resp_body else None), status
        except urllib.error.HTTPError as e:
            error_body = e.read().decode()
            try:
                error_data = json.loads(error_body)
            except json.JSONDecodeError:
                error_data = {"raw": error_body}
            raise JiraApiError(e.code, error_data) from e

    def _get(self, path: str, params: dict | None = None) -> dict:
        result, _ = self._request("GET", path, params=params)
        return result

    def _post(self, path: str, data: dict) -> tuple[dict | None, int]:
        return self._request("POST", path, data=data)

    def _delete(self, path: str) -> tuple[dict | None, int]:
        return self._request("DELETE", path)

    def _put(self, path: str, data: dict) -> tuple[dict | None, int]:
        return self._request("PUT", path, data=data)

    # ── Issues ──────────────────────────────────────────

    def create_issue(
        self,
        project_key: str,
        summary: str,
        issue_type: str = "Task",
        components: list[str] | None = None,
        assignee_account_id: str | None = None,
        description: str | None = None,
        labels: list[str] | None = None,
        priority: str | None = None,
        parent_key: str | None = None,
    ) -> dict:
        fields: dict = {
            "project": {"key": project_key},
            "issuetype": {"name": issue_type},
            "summary": summary,
            "assignee": {"accountId": assignee_account_id or self.account_id},
        }
        if components:
            fields["components"] = [{"name": c} for c in components]
        if description:
            fields["description"] = _text_to_adf(description)
        if labels:
            fields["labels"] = labels
        if priority:
            fields["priority"] = {"name": priority}
        if parent_key:
            fields["parent"] = {"key": parent_key}
        result, _ = self._post("/rest/api/3/issue", {"fields": fields})
        return result

    def get_issue(self, issue_key: str) -> dict:
        return self._get(
            f"/rest/api/3/issue/{issue_key}",
            params={"fields": "summary,status,priority,assignee,components,updated,description"},
        )

    def update_issue(self, issue_key: str, fields: dict) -> None:
        self._put(f"/rest/api/3/issue/{issue_key}", {"fields": fields})

    def delete_issue(self, issue_key: str) -> None:
        self._delete(f"/rest/api/3/issue/{issue_key}")

    def search_issues(
        self, jql: str, fields: str = "summary,status,priority,issuetype,assignee,updated", max_results: int = 50,
    ) -> list[dict]:
        result = self._get(
            "/rest/api/3/search/jql",
            params={"jql": jql, "maxResults": str(max_results), "fields": fields},
        )
        return result.get("issues", [])

    def move_to_sprint(self, issue_key: str, sprint_id: int) -> None:
        self._post(
            f"/rest/agile/1.0/sprint/{sprint_id}/issue",
            {"issues": [issue_key]},
        )

    def move_to_backlog(self, issue_keys: list[str]) -> None:
        self._post(
            "/rest/agile/1.0/backlog/issue",
            {"issues": issue_keys},
        )

    def get_transitions(self, issue_key: str) -> list[dict]:
        result = self._get(f"/rest/api/3/issue/{issue_key}/transitions")
        return result.get("transitions", [])

    def transition_issue(self, issue_key: str, transition_id: str) -> None:
        self._post(
            f"/rest/api/3/issue/{issue_key}/transitions",
            {"transition": {"id": transition_id}},
        )

    # ── Comments ────────────────────────────────────────

    def get_comments(self, issue_key: str) -> list[dict]:
        result = self._get(
            f"/rest/api/3/issue/{issue_key}/comment",
            params={"orderBy": "-created", "maxResults": "20"},
        )
        return result.get("comments", [])

    def add_comment(self, issue_key: str, body_adf: dict) -> None:
        self._post(
            f"/rest/api/3/issue/{issue_key}/comment",
            {"body": body_adf},
        )

    # ── Queries ─────────────────────────────────────────

    @staticmethod
    def _assignee_clause(assignee: str | None) -> str:
        if assignee is None or assignee.lower() == "me":
            return "assignee = currentUser()"
        if assignee.lower() == "all":
            return ""
        return f'assignee = "{assignee}"'

    def my_open_tickets(self, project_key: str | None = None, assignee: str | None = None) -> list[dict]:
        clauses = [c for c in [self._assignee_clause(assignee)] if c]
        clauses.append("statusCategory not in (Done)")
        jql = " AND ".join(clauses) + " ORDER BY updated DESC"
        if project_key:
            jql = f"project = {project_key} AND {jql}"
        return self.search_issues(jql)

    def my_sprint_tickets(
        self, project_key: str | None = None, sprint_id: int | None = None,
        assignee: str | None = None,
    ) -> list[dict]:
        sprint_clause = f"sprint = {sprint_id}" if sprint_id else "sprint in openSprints()"
        clauses = [c for c in [self._assignee_clause(assignee)] if c]
        clauses.append(sprint_clause)
        jql = " AND ".join(clauses) + " ORDER BY status ASC, updated DESC"
        if project_key:
            jql = f"project = {project_key} AND {jql}"
        return self.search_issues(jql)

    def my_backlog_tickets(
        self, project_key: str | None = None, max_results: int = 5,
        assignee: str | None = None,
    ) -> list[dict]:
        clauses = [c for c in [self._assignee_clause(assignee)] if c]
        clauses.extend(["sprint not in openSprints()", "statusCategory not in (Done)"])
        jql = " AND ".join(clauses) + " ORDER BY rank ASC"
        if project_key:
            jql = f"project = {project_key} AND {jql}"
        return self.search_issues(jql, max_results=max_results)

    def my_all_tickets(self, project_key: str | None = None, assignee: str | None = None) -> list[dict]:
        clauses = [c for c in [self._assignee_clause(assignee)] if c]
        jql = (" AND ".join(clauses) + " " if clauses else "") + "ORDER BY updated DESC"
        if project_key:
            jql = f"project = {project_key} AND {jql}"
        return self.search_issues(jql)

    # ── Sprints ─────────────────────────────────────────

    def get_sprints(
        self, project_key: str, states: str = "active,future",
    ) -> list[dict]:
        """Get sprints for a project's board."""
        board_id = self._get_board_id(project_key)
        result = self._get(
            f"/rest/agile/1.0/board/{board_id}/sprint",
            params={"state": states},
        )
        return result.get("values", [])

    def _get_board_id(self, project_key: str) -> int:
        result = self._get(
            "/rest/agile/1.0/board", params={"projectKeyOrId": project_key}
        )
        boards = result.get("values", [])
        if not boards:
            raise JiraApiError(404, {"message": f"No board found for {project_key}"})
        return boards[0]["id"]

    def _get_active_sprint_id(self, board_id: int) -> int:
        result = self._get(
            f"/rest/agile/1.0/board/{board_id}/sprint", params={"state": "active"}
        )
        sprints = result.get("values", [])
        if not sprints:
            raise JiraApiError(404, {"message": "No active sprint found"})
        return sprints[0]["id"]

    # ── Projects & Components ───────────────────────────

    def get_components(self, project_key: str) -> list[str]:
        result = self._get(f"/rest/api/3/project/{project_key}/components")
        return [c["name"] for c in result]

    def search_projects(self, query: str = "") -> list[dict]:
        """Search for JIRA projects. Returns [{key, name}, ...]."""
        params: dict = {"maxResults": "50", "orderBy": "name"}
        if query:
            params["query"] = query
        result = self._get("/rest/api/3/project/search", params=params)
        return [
            {"key": p["key"], "name": p.get("name", "")}
            for p in result.get("values", [])
        ]

    # ── Users & Groups ──────────────────────────────────

    def search_groups(self, query: str = "") -> list[dict]:
        """Search for Atlassian groups. Returns [{name, groupId}, ...]."""
        params = {"maxResults": "20"}
        if query:
            params["query"] = query
        result = self._get("/rest/api/3/groups/picker", params=params)
        groups = result.get("groups", [])
        for g in groups:
            g["name"] = g["name"].strip()
        return groups

    def get_group_members(self, group_id: str) -> list[dict]:
        result = self._get(
            "/rest/api/3/group/member",
            params={"groupId": group_id, "maxResults": "200"},
        )
        return [
            {"accountId": m["accountId"], "displayName": m.get("displayName", "")}
            for m in result.get("values", [])
            if m.get("accountType") == "atlassian"
        ]

    def get_assignable_users(self, project_key: str, query: str = "") -> list[dict]:
        params = {"project": project_key, "maxResults": "50"}
        if query:
            params["query"] = query
        result = self._get("/rest/api/3/user/assignable/search", params=params)
        return [
            {"accountId": u["accountId"], "displayName": u.get("displayName", "")}
            for u in result
            if u.get("accountType") == "atlassian"
        ]

    def get_team_members(self, project_key: str) -> list[dict]:
        """Get team members: from configured groups if set, else assignable users."""
        groups = config.load().get("team_groups", [])
        if groups:
            seen = set()
            members = []
            for group in groups:
                group_id = group["group_id"] if isinstance(group, dict) else group
                for m in self.get_group_members(group_id):
                    if m["accountId"] not in seen:
                        seen.add(m["accountId"])
                        members.append(m)
            members.sort(key=lambda m: m["displayName"].lower())
            return members
        return self.get_assignable_users(project_key)

    def resolve_assignee(self, project_key: str, assignee_input: str) -> str:
        """Resolve an assignee display name or 'me' to an account ID."""
        if assignee_input.lower() == "me":
            return self.account_id
        members = self.get_team_members(project_key)
        query = assignee_input.lower()
        for m in members:
            if m["displayName"].lower() == query:
                click.echo(f"Assignee: {m['displayName']}")
                return m["accountId"]
        matches = [m for m in members if query in m["displayName"].lower()]
        if len(matches) == 1:
            click.echo(f"Assignee: {matches[0]['displayName']}")
            return matches[0]["accountId"]
        if len(matches) > 1:
            click.echo(f"Multiple matches for '{assignee_input}':")
            for i, m in enumerate(matches, 1):
                click.echo(f"  [{i}] {m['displayName']}")
            choice = click.prompt(
                "Select assignee",
                type=click.IntRange(1, len(matches)),
            )
            selected = matches[choice - 1]
            click.echo(f"Assignee: {selected['displayName']}")
            return selected["accountId"]
        raise click.ClickException(f"No team member found matching '{assignee_input}'")


# ── Completion Cache ────────────────────────────────────


class CompletionCache:
    _DIR = Path(tempfile.gettempdir()) / "ticket-completions"

    def read(self, name: str, ttl_seconds: int = 300) -> list[str] | None:
        path = self._DIR / f"{name}.json"
        try:
            if time.time() - path.stat().st_mtime > ttl_seconds:
                return None
            return json.loads(path.read_text())
        except (FileNotFoundError, json.JSONDecodeError, OSError):
            return None

    def write(self, name: str, values: list[str]) -> None:
        self._DIR.mkdir(parents=True, exist_ok=True)
        (self._DIR / f"{name}.json").write_text(json.dumps(values))


cache = CompletionCache()


# ── Output Formatting ──────────────────────────────────


class Formatter:
    STATUS_ORDER = [
        "open", "in development", "in progress", "blocked",
        "ready for verification", "ready to deploy", "done", "closed",
    ]
    STATUS_COLORS = {
        "open": "white",
        "in development": "blue",
        "in progress": "blue",
        "blocked": "red",
        "ready for verification": "yellow",
        "ready to deploy": "yellow",
        "done": "green",
        "closed": "bright_black",
    }
    TYPE_ICONS = {
        "task": ("\u2611", "blue"),
        "bug": ("!", "red"),
        "story": ("S", "green"),
        "epic": ("\u2632", "magenta"),
    }

    def status_color(self, status: str) -> str:
        return self.STATUS_COLORS.get(status.lower(), "white")

    def type_icon(self, issue_type: str) -> str:
        icon, color = self.TYPE_ICONS.get(issue_type.lower(), ("?", None))
        return click.style(f"[{icon}]", fg=color) if color else f"[{icon}]"

    def _status_sort_key(self, issue: dict) -> int:
        status = issue["fields"].get("status", {}).get("name", "").lower()
        try:
            return self.STATUS_ORDER.index(status)
        except ValueError:
            return len(self.STATUS_ORDER)

    @staticmethod
    def _assignee_name(fields: dict) -> str:
        assignee = fields.get("assignee")
        if not assignee:
            return "Unassigned"
        name = assignee.get("displayName", "")
        parts = name.split()
        if len(parts) >= 2:
            return f"{parts[0]} {parts[-1][0]}."
        return name

    def ticket_table(self, issues: list[dict], show_assignee: bool = False) -> None:
        if not issues:
            click.echo("  No tickets found.")
            return

        sorted_issues = sorted(issues, key=self._status_sort_key)

        key_width = max(len(i["key"]) for i in sorted_issues)
        status_width = max(
            len(i["fields"].get("status", {}).get("name", "Unknown"))
            for i in sorted_issues
        ) + 2
        if show_assignee:
            assignee_width = max(
                len(self._assignee_name(i["fields"])) for i in sorted_issues
            )

        for issue in sorted_issues:
            key = issue["key"]
            fields = issue["fields"]
            summary = fields.get("summary", "")
            status = fields.get("status", {}).get("name", "Unknown")
            issue_type = fields.get("issuetype", {}).get("name", "")

            color = self.status_color(status)
            status_str = click.style(f"[{status}]".ljust(status_width), fg=color)
            type_str = self.type_icon(issue_type)

            if show_assignee:
                name = self._assignee_name(fields)
                assignee_str = f"  {name:<{assignee_width}}"
            else:
                assignee_str = ""

            max_summary = 60
            if len(summary) > max_summary:
                summary = summary[: max_summary - 1] + "\u2026"

            click.echo(f"  {key:<{key_width}}  {status_str}  {type_str}{assignee_str}  {summary}")


fmt = Formatter()


# ── Shell Completions ──────────────────────────────────


def _complete_project(ctx: click.Context, param: click.Parameter, incomplete: str) -> list[click.shell_completion.CompletionItem]:
    projects = config.load().get("projects", [])
    if projects:
        return [
            click.shell_completion.CompletionItem(p["key"], help=p["name"])
            for p in projects if incomplete.upper() in p["key"].upper()
        ]
    cache_key = "projects"
    items = cache.read(cache_key)
    if items is None:
        try:
            found = config.client.search_projects(incomplete)
            items = [f"{p['key']}\t{p['name']}" for p in found]
            cache.write(cache_key, items)
        except Exception:
            return []
    results = []
    for item in items:
        key, _, name = item.partition("\t")
        if incomplete.upper() in key.upper():
            results.append(click.shell_completion.CompletionItem(key, help=name))
    return results


def _complete_components(ctx: click.Context, param: click.Parameter, incomplete: str) -> list[click.shell_completion.CompletionItem]:
    project = ctx.params.get("project") or config.project()
    cache_key = f"components-{project}"
    names = cache.read(cache_key)
    if names is None:
        try:
            names = config.client.get_components(project)
            cache.write(cache_key, names)
        except Exception:
            return []
    return [
        click.shell_completion.CompletionItem(n)
        for n in names if n.lower().startswith(incomplete.lower())
    ]


def _complete_issue_key(ctx: click.Context, param: click.Parameter, incomplete: str) -> list[click.shell_completion.CompletionItem]:
    project = config.project()
    cache_key = f"issues-{project}"
    items = cache.read(cache_key, ttl_seconds=120)
    if items is None:
        try:
            issues = config.client.my_open_tickets(project)
            items = [f"{i['key']}\t{i['fields'].get('summary', '')}" for i in issues]
            cache.write(cache_key, items)
        except Exception:
            return []
    results = []
    for item in items:
        key, _, summary = item.partition("\t")
        if key.lower().startswith(incomplete.lower()):
            results.append(click.shell_completion.CompletionItem(key, help=summary))
    return results


def _complete_parent(ctx: click.Context, param: click.Parameter, incomplete: str) -> list[click.shell_completion.CompletionItem]:
    project = ctx.params.get("project") or config.project()
    cache_key = f"parents-{project}"
    items = cache.read(cache_key, ttl_seconds=300)
    if items is None:
        try:
            jql = (
                f"project = {project} AND statusCategory not in (Done) "
                "ORDER BY issuetype ASC, updated DESC"
            )
            issues = config.client.search_issues(
                jql, fields="summary,issuetype", max_results=50,
            )
            items = [
                f"{i['key']}\t{i['fields'].get('issuetype', {}).get('name', '')}\t{i['fields'].get('summary', '')}"
                for i in issues
            ]
            cache.write(cache_key, items)
        except Exception:
            return []
    EPIC_TYPES = {"epic"}
    results = []
    for item in items:
        key, itype, summary = item.split("\t", 2)
        if not key.lower().startswith(incomplete.lower()):
            continue
        is_epic = itype.lower() in EPIC_TYPES
        help_text = f"[{itype}] {summary}" if itype else summary
        results.append((not is_epic, click.shell_completion.CompletionItem(key, help=help_text)))
    results.sort(key=lambda x: x[0])
    return [r[1] for r in results]


def _complete_transition(ctx: click.Context, param: click.Parameter, incomplete: str) -> list[click.shell_completion.CompletionItem]:
    issue_key = ctx.params.get("issue_key")
    if not issue_key:
        return []
    cache_key = f"transitions-{issue_key}"
    items = cache.read(cache_key, ttl_seconds=120)
    if items is None:
        try:
            transitions = config.client.get_transitions(issue_key)
            items = [t["name"] for t in transitions]
            cache.write(cache_key, items)
        except Exception:
            return []
    return [
        click.shell_completion.CompletionItem(name)
        for name in items if incomplete.lower() in name.lower()
    ]


def _complete_sprint(ctx: click.Context, param: click.Parameter, incomplete: str) -> list[click.shell_completion.CompletionItem]:
    project = ctx.params.get("project") or config.project()
    cache_key = f"sprints-{project}"
    items = cache.read(cache_key, ttl_seconds=300)
    if items is None:
        try:
            sprints = config.client.get_sprints(project)
            items = [f"{s['id']}\t{s['name']}" for s in sprints]
            cache.write(cache_key, items)
        except Exception:
            return []
    results = [click.shell_completion.CompletionItem("backlog", help="Move to backlog")]
    for item in items:
        sid, _, name = item.partition("\t")
        if incomplete.lower() in name.lower() or incomplete in sid:
            results.append(click.shell_completion.CompletionItem(name, help=f"Sprint {sid}"))
    return results


def _complete_assignee(ctx: click.Context, param: click.Parameter, incomplete: str) -> list[click.shell_completion.CompletionItem]:
    project = ctx.params.get("project") or config.project()
    cache_key = f"team-{project}"
    items = cache.read(cache_key)
    if items is None:
        try:
            members = config.client.get_team_members(project)
            items = [f"{m['accountId']}\t{m['displayName']}" for m in members]
            cache.write(cache_key, items)
        except Exception:
            return []
    results = []
    for item in items:
        account_id, _, display_name = item.partition("\t")
        if incomplete.lower() in display_name.lower():
            results.append(click.shell_completion.CompletionItem(display_name, help=account_id))
    return results


# ── CLI Commands ────────────────────────────────────────


@click.group()
def cli():
    """JIRA ticket manager."""


@cli.command()
@click.argument("summary")
@click.option("--now", is_flag=True, help="Add to current active sprint")
@click.option("-c", "--component", multiple=True, help="Component name(s)", shell_complete=_complete_components)
@click.option("-a", "--assignee", default="me", help="Assignee name (default: me)", shell_complete=_complete_assignee)
@click.option("-p", "--project", default=None, help="Project key (default: last used)", shell_complete=_complete_project)
@click.option("-t", "--type", "issue_type", default="Task", help="Issue type")
@click.option("-d", "--description", default=None, help="Description text")
@click.option("-l", "--label", multiple=True, help="Label(s)")
@click.option("--priority", default=None, help="Priority (e.g. High, Medium, Low)")
@click.option("--parent", default=None, help="Parent issue key (for subtasks)", shell_complete=_complete_parent)
def create(
    summary: str, now: bool, component: tuple, assignee: str,
    project: str | None, issue_type: str, description: str | None,
    label: tuple, priority: str | None, parent: str | None,
):
    """Create a new JIRA ticket."""
    client = config.client
    project_key = config.project(project)

    try:
        assignee_id = client.resolve_assignee(project_key, assignee)
        result = client.create_issue(
            project_key, summary, issue_type,
            list(component) if component else None,
            assignee_account_id=assignee_id,
            description=description,
            labels=list(label) if label else None,
            priority=priority,
            parent_key=parent,
        )
        issue_key = result["key"]
        config.save({"default_project": project_key})
        click.echo(f"Created {issue_key}: {summary}")

        if now:
            board_id = client._get_board_id(project_key)
            sprint_id = client._get_active_sprint_id(board_id)
            client.move_to_sprint(issue_key, sprint_id)
            click.echo("Added to current sprint")

        click.echo(f"{config.base_url}/browse/{issue_key}")

    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command("list")
@click.option("-p", "--project", default=None, help="Filter by project", shell_complete=_complete_project)
@click.option("-a", "--assignee", default="me", help="Filter by assignee (default: me, 'all' for everyone)", shell_complete=_complete_assignee)
@click.option("--sprint", "sprint_id", default=None,
               help="Filter by sprint: 'current' or a sprint ID")
@click.option("--backlog", is_flag=True, help="Backlog only")
@click.option("--all", "show_all", is_flag=True, help="Include Done tickets")
def list_tickets(project: str | None, assignee: str, sprint_id: str | None, backlog: bool, show_all: bool):
    """List assigned tickets.

    \b
    By default shows your current sprint tickets followed by the top 5 backlog items.
    Use -a to filter by assignee, or -a all to show everyone's tickets.
    """
    client = config.client
    project_key = config.project(project)
    show_names = assignee.lower() != "me"

    try:
        if show_all:
            issues = client.my_all_tickets(project_key, assignee=assignee)
            fmt.ticket_table(issues, show_assignee=show_names)
        elif sprint_id is not None:
            sid = None if sprint_id == "current" else int(sprint_id)
            issues = client.my_sprint_tickets(project_key, sprint_id=sid, assignee=assignee)
            fmt.ticket_table(issues, show_assignee=show_names)
        elif backlog:
            issues = client.my_backlog_tickets(project_key, max_results=20, assignee=assignee)
            fmt.ticket_table(issues, show_assignee=show_names)
        else:
            sprint_issues = client.my_sprint_tickets(project_key, assignee=assignee)
            backlog_issues = client.my_backlog_tickets(project_key, max_results=5, assignee=assignee)

            click.echo(click.style("Sprint", bold=True))
            if sprint_issues:
                fmt.ticket_table(sprint_issues, show_assignee=show_names)
            else:
                click.echo("  No sprint tickets.")

            click.echo()
            click.echo(click.style("Backlog", bold=True))
            if backlog_issues:
                fmt.ticket_table(backlog_issues, show_assignee=show_names)
                click.echo("  ...")
            else:
                click.echo("  No backlog tickets.")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command("sprints")
@click.option("-p", "--project", default=None, help="Project key", shell_complete=_complete_project)
@click.option("--all", "show_all", is_flag=True, help="Include closed sprints")
def list_sprints(project: str | None, show_all: bool):
    """List sprints for the project board."""
    client = config.client
    project_key = config.project(project)
    states = "active,future,closed" if show_all else "active,future"

    try:
        sprints = client.get_sprints(project_key, states=states)
        if not sprints:
            click.echo("No sprints found.")
            return
        id_width = max(len(str(s["id"])) for s in sprints)
        for s in sprints:
            state = s.get("state", "unknown")
            color = {"active": "green", "future": "blue", "closed": "bright_black"}.get(state, "white")
            state_str = click.style(f"[{state}]", fg=color)
            click.echo(f"  {s['id']:<{id_width}}  {state_str:<20}  {s.get('name', '')}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("issue_key", shell_complete=_complete_issue_key)
def show(issue_key: str):
    """Show details of a ticket."""
    client = config.client
    try:
        issue = client.get_issue(issue_key)
        fields = issue["fields"]
        status = fields.get("status", {}).get("name", "Unknown")
        priority = fields.get("priority", {}).get("name", "")
        assignee = fields.get("assignee", {})
        assignee_name = assignee.get("displayName", "Unassigned") if assignee else "Unassigned"
        components = ", ".join(c["name"] for c in fields.get("components", []))

        color = fmt.status_color(status)
        click.echo(f"  {issue['key']}  {click.style(status, fg=color)}")
        click.echo(f"  {fields.get('summary', '')}")
        click.echo(f"  Assignee: {assignee_name}")
        if priority:
            click.echo(f"  Priority: {priority}")
        if components:
            click.echo(f"  Components: {components}")
        click.echo(f"  {config.base_url}/browse/{issue['key']}")

        description = _adf_to_text(fields.get("description")).strip()
        if description:
            click.echo()
            click.echo(click.style("  Description", bold=True))
            for line in description.split("\n"):
                click.echo(f"  {line}")

        comments = client.get_comments(issue_key)
        if comments:
            click.echo()
            click.echo(click.style(f"  Comments ({len(comments)})", bold=True))
            for c in comments:
                author = c.get("author", {}).get("displayName", "Unknown")
                created = c.get("created", "")[:10]
                body = _adf_to_text(c.get("body")).strip()
                click.echo()
                click.echo(f"  {click.style(author, bold=True)}  {click.style(created, fg='bright_black')}")
                for line in body.split("\n"):
                    click.echo(f"    {line}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("issue_key", shell_complete=_complete_issue_key)
def edit(issue_key: str):
    """Edit a ticket's summary and description.

    Opens $EDITOR with the current values. Reads from stdin if piped.

    \b
    Editor format:
        Summary line here
        ──── description ────
        Description text here
    """
    client = config.client
    try:
        issue = client.get_issue(issue_key)
        fields = issue["fields"]
        old_summary = fields.get("summary", "")
        old_description = _adf_to_text(fields.get("description")).strip()

        if sys.stdin.isatty():
            text = click.edit(
                _compose_edit_text(old_summary, old_description),
                extension=".md",
            )
            if text is None:
                click.echo("No changes (editor closed without saving).")
                return
        else:
            text = sys.stdin.read()

        new_summary, new_description = _parse_edit_text(text)

        if not new_summary:
            raise click.ClickException("Summary cannot be empty")

        update: dict = {}
        if new_summary != old_summary:
            update["summary"] = new_summary
        if new_description != old_description:
            update["description"] = _text_to_adf(new_description)

        if not update:
            click.echo("No changes.")
            return

        client.update_issue(issue_key, update)
        changed = " and ".join(update.keys())
        click.echo(f"Updated {issue_key} ({changed})")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("issue_key", shell_complete=_complete_issue_key)
@click.argument("text", required=False)
def comment(issue_key: str, text: str | None):
    """Add a comment to a ticket.

    \b
    Three ways to provide the comment body:
        ticket comment WEAT-123 "Fixed the flaky test"
        echo "some comment" | ticket comment WEAT-123
        ticket comment WEAT-123              # opens $EDITOR
    """
    client = config.client
    try:
        if text:
            body = text
        elif not sys.stdin.isatty():
            body = sys.stdin.read().strip()
        else:
            body = click.edit(extension=".md")
            if body is None:
                click.echo("No comment (editor closed without saving).")
                return
            body = body.strip()

        if not body:
            raise click.ClickException("Comment cannot be empty")

        client.add_comment(issue_key, _text_to_adf(body))
        click.echo(f"Commented on {issue_key}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("issue_key", shell_complete=_complete_issue_key)
@click.option("-y", "--yes", is_flag=True, help="Skip confirmation")
def delete(issue_key: str, yes: bool):
    """Delete a ticket.

    \b
    Examples:
        ticket delete WEAT-123
        ticket delete WEAT-123 --yes
    """
    client = config.client
    try:
        if not yes:
            issue = client.get_issue(issue_key)
            summary = issue["fields"].get("summary", "")
            click.echo(f"  {issue_key}: {summary}")
            click.confirm("Delete this ticket?", abort=True)
        client.delete_issue(issue_key)
        click.echo(f"Deleted {issue_key}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("issue_key", shell_complete=_complete_issue_key)
@click.argument("assignee", required=False, shell_complete=_complete_assignee)
@click.option("--none", "unassign", is_flag=True, help="Unassign the ticket")
def assign(issue_key: str, assignee: str | None, unassign: bool):
    """Reassign a ticket.

    \b
    Examples:
        ticket assign WEAT-123 "Jane Smith"
        ticket assign WEAT-123 me
        ticket assign WEAT-123 --none
    """
    client = config.client
    try:
        if unassign:
            client.update_issue(issue_key, {"assignee": None})
            click.echo(f"Unassigned {issue_key}")
        elif assignee:
            project_key = issue_key.rsplit("-", 1)[0]
            account_id = client.resolve_assignee(project_key, assignee)
            client.update_issue(issue_key, {"assignee": {"accountId": account_id}})
            click.echo(f"Assigned {issue_key}")
        else:
            raise click.ClickException("Provide an assignee name or use --none to unassign")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("jql")
@click.option("-m", "--max-results", default=50, type=int, help="Max results (default: 50)")
def search(jql: str, max_results: int):
    """Search for tickets using a JQL query.

    \b
    Examples:
        ticket search 'project = WEAT AND labels = "tech-debt" ORDER BY updated DESC'
        ticket search 'text ~ "deploy pipeline"'
        ticket search 'assignee = currentUser() AND status = "In Development"'
    """
    client = config.client
    try:
        issues = client.search_issues(jql, max_results=max_results)
        fmt.ticket_table(issues)
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("issue_key", shell_complete=_complete_issue_key)
@click.argument("status", shell_complete=_complete_transition)
def status(issue_key: str, status: str):
    """Transition a ticket to a new status.

    \b
    Examples:
        ticket status WEAT-123 "In Development"
        ticket status WEAT-123 done
    """
    client = config.client
    try:
        transitions = client.get_transitions(issue_key)
        if not transitions:
            raise click.ClickException(f"No transitions available for {issue_key}")

        query = status.lower()
        # Exact match first
        selected = None
        for t in transitions:
            if t["name"].lower() == query:
                selected = t
                break
        # Substring match
        if not selected:
            matches = [t for t in transitions if query in t["name"].lower()]
            if len(matches) == 1:
                selected = matches[0]
            elif len(matches) > 1:
                names = ", ".join(f"'{t['name']}'" for t in matches)
                raise click.ClickException(
                    f"Ambiguous status '{status}' matches: {names}"
                )

        if not selected:
            names = ", ".join(f"'{t['name']}'" for t in transitions)
            raise click.ClickException(
                f"No transition matching '{status}'. Available: {names}"
            )

        client.transition_issue(issue_key, selected["id"])
        click.echo(f"Moved {issue_key} to {selected['name']}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("issue_key", shell_complete=_complete_issue_key)
@click.argument("destination", shell_complete=_complete_sprint)
@click.option("-p", "--project", default=None, help="Project key", shell_complete=_complete_project)
def move(issue_key: str, destination: str, project: str | None):
    """Move a ticket to a sprint or backlog.

    \b
    Examples:
        ticket move WEAT-123 backlog
        ticket move WEAT-123 "Sprint 42"
        ticket move WEAT-123 current
    """
    client = config.client
    project_key = config.project(project) or issue_key.rsplit("-", 1)[0]

    try:
        if destination.lower() == "backlog":
            client.move_to_backlog([issue_key])
            click.echo(f"Moved {issue_key} to backlog")
            return

        sprints = client.get_sprints(project_key)
        if not sprints:
            raise click.ClickException(f"No sprints found for {project_key}")

        if destination.lower() == "current":
            active = [s for s in sprints if s.get("state") == "active"]
            if not active:
                raise click.ClickException("No active sprint found")
            selected = active[0]
        else:
            # Exact match first
            selected = None
            query = destination.lower()
            for s in sprints:
                if s["name"].lower() == query:
                    selected = s
                    break
            # Substring match
            if not selected:
                matches = [s for s in sprints if query in s["name"].lower()]
                if len(matches) == 1:
                    selected = matches[0]
                elif len(matches) > 1:
                    names = ", ".join(f"'{s['name']}'" for s in matches)
                    raise click.ClickException(
                        f"Ambiguous sprint '{destination}' matches: {names}"
                    )
            if not selected:
                names = ", ".join(f"'{s['name']}'" for s in sprints)
                raise click.ClickException(
                    f"No sprint matching '{destination}'. Available: {names}"
                )

        client.move_to_sprint(issue_key, selected["id"])
        click.echo(f"Moved {issue_key} to {selected['name']}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


# ── Team Subcommands ───────────────────────────────────


@cli.group()
def team():
    """Manage team groups for assignee autocomplete."""


@team.command("search")
@click.argument("query")
def team_search(query: str):
    """Search for Atlassian groups by name."""
    client = config.client
    try:
        groups = client.search_groups(query)
        if not groups:
            click.echo("No groups found.")
            return
        name_width = max(len(g["name"]) for g in groups)
        for g in groups:
            gid = click.style(g["groupId"], fg="bright_black")
            click.echo(f"  {g['name']:<{name_width}}  {gid}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@team.command("add")
@click.argument("group_name")
def team_add(group_name: str):
    """Add a group to team_groups config."""
    client = config.client
    results = client.search_groups(group_name)
    match = None
    for g in results:
        if g["name"].lower() == group_name.lower():
            match = g
            break
    if not match:
        matches = [g for g in results if group_name.lower() in g["name"].lower()]
        if len(matches) == 1:
            match = matches[0]
    if not match:
        raise click.ClickException(
            f"Group '{group_name}' not found. Use 'ticket team search' to find the exact name."
        )
    try:
        members = client.get_group_members(match["groupId"])
    except JiraApiError as e:
        raise click.ClickException(f"Cannot access group '{match['name']}': {e}")
    raw = config.load()
    groups = raw.get("team_groups", [])
    existing_names = {
        (g["name"] if isinstance(g, dict) else g) for g in groups
    }
    if match["name"] in existing_names:
        click.echo(f"Already configured: {match['name']}")
        return
    groups.append({"name": match["name"], "group_id": match["groupId"]})
    config.save({"team_groups": groups})
    click.echo(f"Added '{match['name']}' ({len(members)} members) to team_groups")


@team.command("remove")
@click.argument("group_name")
def team_remove(group_name: str):
    """Remove a group from team_groups config."""
    raw = config.load()
    groups = raw.get("team_groups", [])
    new_groups = [
        g for g in groups
        if (g["name"] if isinstance(g, dict) else g).lower() != group_name.lower()
    ]
    if len(new_groups) == len(groups):
        click.echo(f"Not configured: {group_name}")
        return
    config.save({"team_groups": new_groups})
    click.echo(f"Removed '{group_name}' from team_groups")


@team.command("show")
@click.option("-p", "--project", default=None, help="Project key (for fallback list)", shell_complete=_complete_project)
def team_show(project: str | None):
    """Show configured groups and their members."""
    raw = config.load()
    groups = raw.get("team_groups", [])
    client = config.client
    project_key = config.project(project)

    try:
        if groups:
            names = [g["name"] if isinstance(g, dict) else g for g in groups]
            click.echo(f"Configured groups: {', '.join(names)}")
            click.echo()
            members = client.get_team_members(project_key)
        else:
            click.echo("No team_groups configured. Showing assignable users for " + project_key + ":")
            click.echo()
            members = client.get_assignable_users(project_key)

        for m in members:
            click.echo(f"  {m['displayName']}")
        click.echo(f"\n  {len(members)} members")
    except JiraApiError as e:
        raise click.ClickException(str(e))


# ── Project Subcommands ────────────────────────────────


@cli.group()
def project():
    """Manage configured projects."""


@project.command("search")
@click.argument("query")
def project_search(query: str):
    """Search for JIRA projects."""
    client = config.client
    try:
        projects = client.search_projects(query)
        if not projects:
            click.echo("No projects found.")
            return
        key_width = max(len(p["key"]) for p in projects)
        for p in projects:
            click.echo(f"  {p['key']:<{key_width}}  {p['name']}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@project.command("add")
@click.argument("project_key")
def project_add(project_key: str):
    """Add a project to the configured list."""
    client = config.client
    results = client.search_projects(project_key)
    match = None
    for p in results:
        if p["key"].upper() == project_key.upper():
            match = p
            break
    if not match:
        raise click.ClickException(
            f"Project '{project_key}' not found. Use 'ticket project search' to find it."
        )
    raw = config.load()
    projects = raw.get("projects", [])
    existing_keys = {p["key"] for p in projects}
    if match["key"] in existing_keys:
        click.echo(f"Already configured: {match['key']}")
        return
    projects.append({"key": match["key"], "name": match["name"]})
    config.save({"projects": projects})
    click.echo(f"Added {match['key']} ({match['name']})")
    if len(projects) == 1:
        config.save({"default_project": match["key"]})
        click.echo("Set as default project")


@project.command("remove")
@click.argument("project_key")
def project_remove(project_key: str):
    """Remove a project from the configured list."""
    raw = config.load()
    projects = raw.get("projects", [])
    new_projects = [p for p in projects if p["key"].upper() != project_key.upper()]
    if len(new_projects) == len(projects):
        click.echo(f"Not configured: {project_key}")
        return
    config.save({"projects": new_projects})
    click.echo(f"Removed {project_key}")


@project.command("list")
def project_list():
    """Show configured projects."""
    raw = config.load()
    projects = raw.get("projects", [])
    default = config.project()
    if not projects:
        click.echo(f"No projects configured. Current default: {default}")
        return
    for p in projects:
        marker = " *" if p["key"] == default else ""
        click.echo(f"  {p['key']}  {p['name']}{marker}")


@project.command("default")
@click.argument("project_key")
def project_default(project_key: str):
    """Set the default project."""
    raw = config.load()
    projects = raw.get("projects", [])
    configured_keys = {p["key"].upper() for p in projects}
    if projects and project_key.upper() not in configured_keys:
        click.echo(f"Warning: {project_key} is not in your configured projects list")
    config.save({"default_project": project_key.upper()})
    click.echo(f"Default project set to {project_key.upper()}")


# ── Entry Point ─────────────────────────────────────────

if __name__ == "__main__":
    cli()
