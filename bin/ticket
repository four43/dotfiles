#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = ["click>=8.1"]
# ///
"""JIRA ticket CLI."""

import base64
import json
import os
import re
import sys
import tempfile
import time
import urllib.error
import urllib.parse
import urllib.request
from pathlib import Path

import click

# ── Config ──────────────────────────────────────────────

CONFIG_DIR = Path(os.environ.get("XDG_CONFIG_HOME", Path.home() / ".config")) / "ticket"
CONFIG_FILE = CONFIG_DIR / "config.json"

DEFAULT_CONFIG = {
    "base_url": "https://vaisala.atlassian.net",
    "email": "${XWE_JIRA_EMAIL}",
    "api_token": "${XWE_JIRA_API_TOKEN}",
    "default_project": "WEAT",
    "projects": [],
    "team_groups": [],
}

_ENV_VAR_RE = re.compile(r"\$\{([^}]+)\}")


def _expand_env_vars(value: str) -> str:
    """Expand ${VAR_NAME} references in a string from os.environ."""
    def replace(match: re.Match) -> str:
        var_name = match.group(1)
        val = os.environ.get(var_name)
        if val is None:
            raise click.ClickException(
                f"Environment variable ${{{var_name}}} is not set "
                f"(referenced in {CONFIG_FILE})"
            )
        return val

    return _ENV_VAR_RE.sub(replace, value)


def load_config() -> dict:
    """Load raw config (env vars NOT expanded)."""
    try:
        return json.loads(CONFIG_FILE.read_text())
    except FileNotFoundError:
        save_config(DEFAULT_CONFIG)
        return dict(DEFAULT_CONFIG)
    except json.JSONDecodeError:
        click.echo(f"Warning: corrupt config at {CONFIG_FILE}, using defaults", err=True)
        return dict(DEFAULT_CONFIG)


def resolve_config() -> dict:
    """Load config and expand all ${VAR} references."""
    raw = load_config()
    resolved = {}
    for key, value in raw.items():
        if isinstance(value, str):
            resolved[key] = _expand_env_vars(value)
        else:
            resolved[key] = value
    return resolved


def save_config(updates: dict) -> None:
    """Merge updates into existing config and persist."""
    try:
        config = json.loads(CONFIG_FILE.read_text())
    except (FileNotFoundError, json.JSONDecodeError):
        config = dict(DEFAULT_CONFIG)
    config.update(updates)
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    CONFIG_FILE.write_text(json.dumps(config, indent=2) + "\n")


# ── ADF (Atlassian Document Format) ────────────────────

def _adf_to_text(node: dict | None) -> str:
    """Convert an ADF document to plain text."""
    if not node:
        return ""
    ntype = node.get("type", "")
    children = node.get("content", [])

    if ntype == "text":
        return node.get("text", "")
    if ntype == "hardBreak":
        return "\n"
    if ntype == "rule":
        return "\n---\n"

    parts = [_adf_to_text(c) for c in children]
    text = "".join(parts)

    if ntype == "paragraph":
        return text + "\n\n"
    if ntype == "heading":
        level = node.get("attrs", {}).get("level", 1)
        return "#" * level + " " + text + "\n\n"
    if ntype == "bulletList":
        return text
    if ntype == "orderedList":
        return text
    if ntype == "listItem":
        # Indent and prefix child paragraphs
        lines = text.strip().split("\n")
        return "- " + "\n  ".join(lines) + "\n"
    if ntype == "blockquote":
        return "".join("> " + line + "\n" for line in text.strip().split("\n")) + "\n"
    if ntype == "codeBlock":
        lang = node.get("attrs", {}).get("language", "")
        return f"```{lang}\n{text}```\n\n"

    return text


def _text_to_adf(text: str) -> dict:
    """Convert plain text to a simple ADF document."""
    content = []
    for para in text.split("\n\n"):
        para = para.strip()
        if not para:
            continue
        # Convert inline newlines to hardBreaks
        inline: list[dict] = []
        lines = para.split("\n")
        for i, line in enumerate(lines):
            if i > 0:
                inline.append({"type": "hardBreak"})
            inline.append({"type": "text", "text": line})
        content.append({"type": "paragraph", "content": inline})
    return {"type": "doc", "version": 1, "content": content or [
        {"type": "paragraph", "content": []}
    ]}


EDIT_SEPARATOR = "──── description ────"


def _compose_edit_text(summary: str, description: str) -> str:
    """Build the text shown in the editor."""
    return f"{summary}\n{EDIT_SEPARATOR}\n{description}"


def _parse_edit_text(text: str) -> tuple[str, str]:
    """Parse editor text back into (summary, description)."""
    if EDIT_SEPARATOR in text:
        summary, _, description = text.partition(EDIT_SEPARATOR)
    else:
        # Fallback: first line is summary, rest is description
        summary, _, description = text.partition("\n")
    return summary.strip(), description.strip()


# ── Errors ──────────────────────────────────────────────


class JiraApiError(Exception):
    def __init__(self, status_code: int, body: dict):
        self.status_code = status_code
        self.body = body
        messages = body.get("errorMessages", [])
        errors = body.get("errors", {})
        if messages:
            detail = "; ".join(messages)
        elif errors:
            detail = "; ".join(f"{k}: {v}" for k, v in errors.items())
        else:
            detail = str(body)
        super().__init__(f"HTTP {status_code}: {detail}")


# ── JIRA Client ─────────────────────────────────────────


class JiraClient:
    def __init__(self, base_url: str, email: str, api_token: str):
        self.base_url = base_url.rstrip("/")
        self._auth_header = "Basic " + base64.b64encode(
            f"{email}:{api_token}".encode()
        ).decode()
        self._account_id: str | None = None

    @property
    def account_id(self) -> str:
        if self._account_id is None:
            me = self._get("/rest/api/3/myself")
            self._account_id = me["accountId"]
        return self._account_id

    def _request(
        self,
        method: str,
        path: str,
        data: dict | None = None,
        params: dict | None = None,
    ) -> tuple[dict | None, int]:
        url = self.base_url + path
        if params:
            url += "?" + urllib.parse.urlencode(params, quote_via=urllib.parse.quote)

        body = json.dumps(data).encode() if data else None
        req = urllib.request.Request(url, data=body, method=method)
        req.add_header("Authorization", self._auth_header)
        req.add_header("Content-Type", "application/json")
        req.add_header("Accept", "application/json")

        try:
            resp = urllib.request.urlopen(req)
            status = resp.status
            resp_body = resp.read().decode()
            return (json.loads(resp_body) if resp_body else None), status
        except urllib.error.HTTPError as e:
            error_body = e.read().decode()
            try:
                error_data = json.loads(error_body)
            except json.JSONDecodeError:
                error_data = {"raw": error_body}
            raise JiraApiError(e.code, error_data) from e

    def _get(self, path: str, params: dict | None = None) -> dict:
        result, _ = self._request("GET", path, params=params)
        return result

    def _post(self, path: str, data: dict) -> tuple[dict | None, int]:
        return self._request("POST", path, data=data)

    def _put(self, path: str, data: dict) -> tuple[dict | None, int]:
        return self._request("PUT", path, data=data)

    def create_issue(
        self,
        project_key: str,
        summary: str,
        issue_type: str = "Task",
        components: list[str] | None = None,
        assignee_account_id: str | None = None,
    ) -> dict:
        fields: dict = {
            "project": {"key": project_key},
            "issuetype": {"name": issue_type},
            "summary": summary,
            "assignee": {"accountId": assignee_account_id or self.account_id},
        }
        if components:
            fields["components"] = [{"name": c} for c in components]
        result, _ = self._post("/rest/api/3/issue", {"fields": fields})
        return result

    def move_to_active_sprint(self, project_key: str, issue_key: str) -> None:
        board_id = self._get_board_id(project_key)
        sprint_id = self._get_active_sprint_id(board_id)
        self._post(
            f"/rest/agile/1.0/sprint/{sprint_id}/issue",
            {"issues": [issue_key]},
        )

    def search_issues(
        self, jql: str, fields: str = "summary,status,priority,updated", max_results: int = 50,
    ) -> list[dict]:
        result = self._get(
            "/rest/api/3/search/jql",
            params={"jql": jql, "maxResults": str(max_results), "fields": fields},
        )
        return result.get("issues", [])

    def my_open_tickets(self, project_key: str | None = None) -> list[dict]:
        jql = "assignee = currentUser() AND statusCategory not in (Done) ORDER BY updated DESC"
        if project_key:
            jql = f"project = {project_key} AND {jql}"
        return self.search_issues(jql)

    def my_sprint_tickets(
        self, project_key: str | None = None, sprint_id: int | None = None,
    ) -> list[dict]:
        if sprint_id:
            sprint_clause = f"sprint = {sprint_id}"
        else:
            sprint_clause = "sprint in openSprints()"
        jql = f"assignee = currentUser() AND {sprint_clause} ORDER BY status ASC, updated DESC"
        if project_key:
            jql = f"project = {project_key} AND {jql}"
        return self.search_issues(jql)

    def get_sprints(
        self, project_key: str, states: str = "active,future",
    ) -> list[dict]:
        """Get sprints for a project's board. Returns [{id, name, state, startDate, endDate}, ...]."""
        board_id = self._get_board_id(project_key)
        result = self._get(
            f"/rest/agile/1.0/board/{board_id}/sprint",
            params={"state": states},
        )
        return result.get("values", [])

    def my_backlog_tickets(
        self, project_key: str | None = None, max_results: int = 5
    ) -> list[dict]:
        jql = "assignee = currentUser() AND sprint not in openSprints() AND statusCategory not in (Done) ORDER BY rank ASC"
        if project_key:
            jql = f"project = {project_key} AND {jql}"
        return self.search_issues(jql, max_results=max_results)

    def my_all_tickets(self, project_key: str | None = None) -> list[dict]:
        jql = "assignee = currentUser() ORDER BY updated DESC"
        if project_key:
            jql = f"project = {project_key} AND {jql}"
        return self.search_issues(jql)

    def get_transitions(self, issue_key: str) -> list[dict]:
        result = self._get(f"/rest/api/3/issue/{issue_key}/transitions")
        return result.get("transitions", [])

    def transition_issue(self, issue_key: str, transition_id: str) -> None:
        self._post(
            f"/rest/api/3/issue/{issue_key}/transitions",
            {"transition": {"id": transition_id}},
        )

    def get_components(self, project_key: str) -> list[str]:
        result = self._get(f"/rest/api/3/project/{project_key}/components")
        return [c["name"] for c in result]

    def get_issue(self, issue_key: str) -> dict:
        return self._get(
            f"/rest/api/3/issue/{issue_key}",
            params={"fields": "summary,status,priority,assignee,components,updated,description"},
        )

    def update_issue(self, issue_key: str, fields: dict) -> None:
        self._put(f"/rest/api/3/issue/{issue_key}", {"fields": fields})

    def add_comment(self, issue_key: str, body_adf: dict) -> None:
        self._post(
            f"/rest/api/3/issue/{issue_key}/comment",
            {"body": body_adf},
        )

    def search_projects(self, query: str = "") -> list[dict]:
        """Search for JIRA projects. Returns [{key, name}, ...]."""
        params: dict = {"maxResults": "50", "orderBy": "name"}
        if query:
            params["query"] = query
        result = self._get("/rest/api/3/project/search", params=params)
        return [
            {"key": p["key"], "name": p.get("name", "")}
            for p in result.get("values", [])
        ]

    def search_groups(self, query: str = "") -> list[dict]:
        """Search for Atlassian groups. Returns [{name, groupId}, ...]."""
        params = {"maxResults": "20"}
        if query:
            params["query"] = query
        result = self._get("/rest/api/3/groups/picker", params=params)
        groups = result.get("groups", [])
        for g in groups:
            g["name"] = g["name"].strip()
        return groups

    def get_group_members(self, group_id: str) -> list[dict]:
        """Get members of an Atlassian group by ID. Returns [{accountId, displayName}, ...]."""
        result = self._get(
            "/rest/api/3/group/member",
            params={"groupId": group_id, "maxResults": "200"},
        )
        return [
            {"accountId": m["accountId"], "displayName": m.get("displayName", "")}
            for m in result.get("values", [])
            if m.get("accountType") == "atlassian"
        ]

    def get_assignable_users(self, project_key: str, query: str = "") -> list[dict]:
        """Get users assignable to a project. Returns [{accountId, displayName}, ...]."""
        params = {"project": project_key, "maxResults": "50"}
        if query:
            params["query"] = query
        result = self._get("/rest/api/3/user/assignable/search", params=params)
        return [
            {"accountId": u["accountId"], "displayName": u.get("displayName", "")}
            for u in result
            if u.get("accountType") == "atlassian"
        ]

    def get_team_members(self, project_key: str) -> list[dict]:
        """Get team members: from configured groups if set, else assignable users."""
        config = load_config()
        groups = config.get("team_groups", [])
        if groups:
            seen = set()
            members = []
            for group in groups:
                group_id = group["group_id"] if isinstance(group, dict) else group
                for m in self.get_group_members(group_id):
                    if m["accountId"] not in seen:
                        seen.add(m["accountId"])
                        members.append(m)
            members.sort(key=lambda m: m["displayName"].lower())
            return members
        return self.get_assignable_users(project_key)

    def _get_board_id(self, project_key: str) -> int:
        result = self._get(
            "/rest/agile/1.0/board", params={"projectKeyOrId": project_key}
        )
        boards = result.get("values", [])
        if not boards:
            raise JiraApiError(404, {"message": f"No board found for {project_key}"})
        return boards[0]["id"]

    def _get_active_sprint_id(self, board_id: int) -> int:
        result = self._get(
            f"/rest/agile/1.0/board/{board_id}/sprint", params={"state": "active"}
        )
        sprints = result.get("values", [])
        if not sprints:
            raise JiraApiError(404, {"message": "No active sprint found"})
        return sprints[0]["id"]


def make_client() -> JiraClient:
    config = resolve_config()
    email = config.get("email", "")
    api_token = config.get("api_token", "")
    if not email or not api_token:
        raise click.ClickException(
            "email and api_token must be configured in " + str(CONFIG_FILE)
        )
    return JiraClient(config.get("base_url", "https://vaisala.atlassian.net"), email, api_token)


# ── Completion Cache ────────────────────────────────────

CACHE_DIR = Path(tempfile.gettempdir()) / "ticket-completions"


def _read_cache(name: str, ttl_seconds: int = 300) -> list[str] | None:
    path = CACHE_DIR / f"{name}.json"
    try:
        if time.time() - path.stat().st_mtime > ttl_seconds:
            return None
        return json.loads(path.read_text())
    except (FileNotFoundError, json.JSONDecodeError, OSError):
        return None


def _write_cache(name: str, values: list[str]) -> None:
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    (CACHE_DIR / f"{name}.json").write_text(json.dumps(values))


def _complete_project(ctx: click.Context, param: click.Parameter, incomplete: str) -> list[click.shell_completion.CompletionItem]:
    config = load_config()
    projects = config.get("projects", [])
    if projects:
        return [
            click.shell_completion.CompletionItem(p["key"], help=p["name"])
            for p in projects if incomplete.upper() in p["key"].upper()
        ]
    # Fall back to API search
    cache_key = "projects"
    items = _read_cache(cache_key)
    if items is None:
        try:
            client = make_client()
            found = client.search_projects(incomplete)
            items = [f"{p['key']}\t{p['name']}" for p in found]
            _write_cache(cache_key, items)
        except Exception:
            return []
    results = []
    for item in items:
        key, _, name = item.partition("\t")
        if incomplete.upper() in key.upper():
            results.append(click.shell_completion.CompletionItem(key, help=name))
    return results


def _complete_components(ctx: click.Context, param: click.Parameter, incomplete: str) -> list[click.shell_completion.CompletionItem]:
    project = ctx.params.get("project") or get_project(None)
    cache_key = f"components-{project}"
    names = _read_cache(cache_key)
    if names is None:
        try:
            client = make_client()
            names = client.get_components(project)
            _write_cache(cache_key, names)
        except Exception:
            return []
    return [
        click.shell_completion.CompletionItem(n)
        for n in names if n.lower().startswith(incomplete.lower())
    ]


def _complete_issue_key(ctx: click.Context, param: click.Parameter, incomplete: str) -> list[click.shell_completion.CompletionItem]:
    project = get_project(None)
    cache_key = f"issues-{project}"
    items = _read_cache(cache_key, ttl_seconds=120)
    if items is None:
        try:
            client = make_client()
            issues = client.my_open_tickets(project)
            items = [f"{i['key']}\t{i['fields'].get('summary', '')}" for i in issues]
            _write_cache(cache_key, items)
        except Exception:
            return []
    results = []
    for item in items:
        key, _, summary = item.partition("\t")
        if key.lower().startswith(incomplete.lower()):
            results.append(click.shell_completion.CompletionItem(key, help=summary))
    return results


def _complete_assignee(ctx: click.Context, param: click.Parameter, incomplete: str) -> list[click.shell_completion.CompletionItem]:
    project = ctx.params.get("project") or get_project(None)
    cache_key = f"team-{project}"
    items = _read_cache(cache_key)
    if items is None:
        try:
            client = make_client()
            members = client.get_team_members(project)
            items = [f"{m['accountId']}\t{m['displayName']}" for m in members]
            _write_cache(cache_key, items)
        except Exception:
            return []
    results = []
    for item in items:
        account_id, _, display_name = item.partition("\t")
        if incomplete.lower() in display_name.lower():
            results.append(click.shell_completion.CompletionItem(display_name, help=account_id))
    return results


def _resolve_assignee(client: JiraClient, project_key: str, assignee_input: str) -> str:
    """Resolve an assignee display name or 'me' to an account ID."""
    if assignee_input.lower() == "me":
        return client.account_id
    members = client.get_team_members(project_key)
    query = assignee_input.lower()
    # Exact match (full display name)
    for m in members:
        if m["displayName"].lower() == query:
            click.echo(f"Assignee: {m['displayName']}")
            return m["accountId"]
    # Partial match on any part of the name
    matches = [m for m in members if query in m["displayName"].lower()]
    if len(matches) == 1:
        click.echo(f"Assignee: {matches[0]['displayName']}")
        return matches[0]["accountId"]
    if len(matches) > 1:
        click.echo(f"Multiple matches for '{assignee_input}':")
        for i, m in enumerate(matches, 1):
            click.echo(f"  [{i}] {m['displayName']}")
        choice = click.prompt(
            "Select assignee",
            type=click.IntRange(1, len(matches)),
        )
        selected = matches[choice - 1]
        click.echo(f"Assignee: {selected['displayName']}")
        return selected["accountId"]
    raise click.ClickException(f"No team member found matching '{assignee_input}'")


# ── Output Formatting ──────────────────────────────────

# Order and color for statuses (matched case-insensitively)
STATUS_ORDER = [
    "open",
    "in development",
    "in progress",
    "blocked",
    "ready for verification",
    "ready to deploy",
    "done",
    "closed",
]

STATUS_COLORS = {
    "open": "white",
    "in development": "blue",
    "in progress": "blue",
    "blocked": "red",
    "ready for verification": "yellow",
    "ready to deploy": "yellow",
    "done": "green",
    "closed": "bright_black",
}


def _status_sort_key(issue: dict) -> int:
    status = issue["fields"].get("status", {}).get("name", "").lower()
    try:
        return STATUS_ORDER.index(status)
    except ValueError:
        return len(STATUS_ORDER)


def _status_color(status: str) -> str:
    return STATUS_COLORS.get(status.lower(), "white")


def format_ticket_table(issues: list[dict]) -> None:
    if not issues:
        click.echo("  No tickets found.")
        return

    sorted_issues = sorted(issues, key=_status_sort_key)

    # Compute column widths from actual data
    key_width = max(len(i["key"]) for i in sorted_issues)
    status_width = max(
        len(i["fields"].get("status", {}).get("name", "Unknown"))
        for i in sorted_issues
    ) + 2  # for brackets

    for issue in sorted_issues:
        key = issue["key"]
        fields = issue["fields"]
        summary = fields.get("summary", "")
        status = fields.get("status", {}).get("name", "Unknown")

        color = _status_color(status)
        status_str = click.style(f"[{status}]".ljust(status_width), fg=color)

        max_summary = 60
        if len(summary) > max_summary:
            summary = summary[: max_summary - 1] + "…"

        click.echo(f"  {key:<{key_width}}  {status_str}  {summary}")


def get_project(project_override: str | None) -> str:
    if project_override:
        return project_override
    config = load_config()
    return config.get("default_project", config.get("last_project", "WEAT"))


def get_base_url() -> str:
    config = load_config()
    return config.get("base_url", "https://vaisala.atlassian.net")


# ── CLI Commands ────────────────────────────────────────


@click.group()
def cli():
    """JIRA ticket manager."""


@cli.command()
@click.argument("summary")
@click.option("--now", is_flag=True, help="Add to current active sprint")
@click.option("-c", "--component", multiple=True, help="Component name(s)", shell_complete=_complete_components)
@click.option("-a", "--assignee", default="me", help="Assignee name (default: me)", shell_complete=_complete_assignee)
@click.option("-p", "--project", default=None, help="Project key (default: last used)", shell_complete=_complete_project)
@click.option("-t", "--type", "issue_type", default="Task", help="Issue type")
def create(summary: str, now: bool, component: tuple, assignee: str, project: str | None, issue_type: str):
    """Create a new JIRA ticket."""
    client = make_client()
    project_key = get_project(project)

    try:
        assignee_id = _resolve_assignee(client, project_key, assignee)
        result = client.create_issue(
            project_key, summary, issue_type,
            list(component) if component else None,
            assignee_account_id=assignee_id,
        )
        issue_key = result["key"]
        save_config({"default_project": project_key})
        click.echo(f"Created {issue_key}: {summary}")

        if now:
            client.move_to_active_sprint(project_key, issue_key)
            click.echo("Added to current sprint")

        click.echo(f"{get_base_url()}/browse/{issue_key}")

    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command("list")
@click.option("-p", "--project", default=None, help="Filter by project", shell_complete=_complete_project)
@click.option("--sprint", "sprint_id", default=None,
               help="Filter by sprint: 'current' or a sprint ID")
@click.option("--backlog", is_flag=True, help="Backlog only")
@click.option("--all", "show_all", is_flag=True, help="Include Done tickets")
def list_tickets(project: str | None, sprint_id: str | None, backlog: bool, show_all: bool):
    """List your assigned tickets.

    By default shows current sprint tickets followed by the top 5 backlog items.
    Use --sprint current or --sprint <ID> to filter by sprint.
    """
    client = make_client()
    project_key = get_project(project)

    try:
        if show_all:
            issues = client.my_all_tickets(project_key)
            format_ticket_table(issues)
        elif sprint_id is not None:
            sid = None if sprint_id == "current" else int(sprint_id)
            issues = client.my_sprint_tickets(project_key, sprint_id=sid)
            format_ticket_table(issues)
        elif backlog:
            issues = client.my_backlog_tickets(project_key, max_results=20)
            format_ticket_table(issues)
        else:
            sprint_issues = client.my_sprint_tickets(project_key)
            backlog_issues = client.my_backlog_tickets(project_key, max_results=5)

            if sprint_issues:
                click.echo(click.style("Sprint", bold=True))
                format_ticket_table(sprint_issues)
            else:
                click.echo(click.style("Sprint", bold=True))
                click.echo("  No sprint tickets.")

            click.echo()
            click.echo(click.style("Backlog", bold=True))
            if backlog_issues:
                format_ticket_table(backlog_issues)
                click.echo("  ...")
            else:
                click.echo("  No backlog tickets.")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command("sprints")
@click.option("-p", "--project", default=None, help="Project key", shell_complete=_complete_project)
@click.option("--all", "show_all", is_flag=True, help="Include closed sprints")
def list_sprints(project: str | None, show_all: bool):
    """List sprints for the project board."""
    client = make_client()
    project_key = get_project(project)
    states = "active,future,closed" if show_all else "active,future"

    try:
        sprints = client.get_sprints(project_key, states=states)
        if not sprints:
            click.echo("No sprints found.")
            return
        id_width = max(len(str(s["id"])) for s in sprints)
        for s in sprints:
            state = s.get("state", "unknown")
            color = {"active": "green", "future": "blue", "closed": "bright_black"}.get(state, "white")
            state_str = click.style(f"[{state}]", fg=color)
            click.echo(f"  {s['id']:<{id_width}}  {state_str:<20}  {s.get('name', '')}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("issue_key", shell_complete=_complete_issue_key)
def show(issue_key: str):
    """Show details of a ticket."""
    client = make_client()
    try:
        issue = client.get_issue(issue_key)
        fields = issue["fields"]
        status = fields.get("status", {}).get("name", "Unknown")
        priority = fields.get("priority", {}).get("name", "")
        components = ", ".join(c["name"] for c in fields.get("components", []))

        color = _status_color(status)
        click.echo(f"  {issue['key']}  {click.style(status, fg=color)}")
        click.echo(f"  {fields.get('summary', '')}")
        if priority:
            click.echo(f"  Priority: {priority}")
        if components:
            click.echo(f"  Components: {components}")
        click.echo(f"  {get_base_url()}/browse/{issue['key']}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("issue_key", shell_complete=_complete_issue_key)
def edit(issue_key: str):
    """Edit a ticket's summary and description.

    Opens $EDITOR with the current values. Reads from stdin if piped.

    \b
    Editor format:
        Summary line here
        ──── description ────
        Description text here
    """
    client = make_client()
    try:
        issue = client.get_issue(issue_key)
        fields = issue["fields"]
        old_summary = fields.get("summary", "")
        old_description = _adf_to_text(fields.get("description")).strip()

        if sys.stdin.isatty():
            text = click.edit(
                _compose_edit_text(old_summary, old_description),
                extension=".md",
            )
            if text is None:
                click.echo("No changes (editor closed without saving).")
                return
        else:
            text = sys.stdin.read()

        new_summary, new_description = _parse_edit_text(text)

        if not new_summary:
            raise click.ClickException("Summary cannot be empty")

        update: dict = {}
        if new_summary != old_summary:
            update["summary"] = new_summary
        if new_description != old_description:
            update["description"] = _text_to_adf(new_description)

        if not update:
            click.echo("No changes.")
            return

        client.update_issue(issue_key, update)
        changed = " and ".join(update.keys())
        click.echo(f"Updated {issue_key} ({changed})")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("issue_key", shell_complete=_complete_issue_key)
@click.argument("text", required=False)
def comment(issue_key: str, text: str | None):
    """Add a comment to a ticket.

    \b
    Three ways to provide the comment body:
        ticket comment WEAT-123 "Fixed the flaky test"
        echo "some comment" | ticket comment WEAT-123
        ticket comment WEAT-123              # opens $EDITOR
    """
    client = make_client()
    try:
        if text:
            body = text
        elif not sys.stdin.isatty():
            body = sys.stdin.read().strip()
        else:
            body = click.edit(extension=".md")
            if body is None:
                click.echo("No comment (editor closed without saving).")
                return
            body = body.strip()

        if not body:
            raise click.ClickException("Comment cannot be empty")

        client.add_comment(issue_key, _text_to_adf(body))
        click.echo(f"Commented on {issue_key}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.command()
@click.argument("issue_key", shell_complete=_complete_issue_key)
def move(issue_key: str):
    """Transition a ticket to a new status."""
    client = make_client()
    try:
        transitions = client.get_transitions(issue_key)
        if not transitions:
            raise click.ClickException(f"No transitions available for {issue_key}")

        click.echo(f"Available transitions for {issue_key}:")
        for i, t in enumerate(transitions, 1):
            click.echo(f"  [{i}] {t['name']}")

        choice = click.prompt(
            "Select transition",
            type=click.IntRange(1, len(transitions)),
        )
        selected = transitions[choice - 1]
        client.transition_issue(issue_key, selected["id"])
        click.echo(f"Moved {issue_key} to {selected['name']}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.group()
def team():
    """Manage team groups for assignee autocomplete."""


@team.command("search")
@click.argument("query")
def team_search(query: str):
    """Search for Atlassian groups by name."""
    client = make_client()
    try:
        groups = client.search_groups(query)
        if not groups:
            click.echo("No groups found.")
            return
        name_width = max(len(g["name"]) for g in groups)
        for g in groups:
            gid = click.style(g["groupId"], fg="bright_black")
            click.echo(f"  {g['name']:<{name_width}}  {gid}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@team.command("add")
@click.argument("group_name")
def team_add(group_name: str):
    """Add a group to team_groups config."""
    client = make_client()
    # Search for the group to get its ID
    results = client.search_groups(group_name)
    match = None
    for g in results:
        if g["name"].lower() == group_name.lower():
            match = g
            break
    if not match:
        # Try partial match if only one result
        matches = [g for g in results if group_name.lower() in g["name"].lower()]
        if len(matches) == 1:
            match = matches[0]
    if not match:
        raise click.ClickException(
            f"Group '{group_name}' not found. Use 'ticket team search' to find the exact name."
        )
    # Validate we can fetch members
    try:
        members = client.get_group_members(match["groupId"])
    except JiraApiError as e:
        raise click.ClickException(f"Cannot access group '{match['name']}': {e}")
    config = load_config()
    groups = config.get("team_groups", [])
    existing_names = {
        (g["name"] if isinstance(g, dict) else g) for g in groups
    }
    if match["name"] in existing_names:
        click.echo(f"Already configured: {match['name']}")
        return
    groups.append({"name": match["name"], "group_id": match["groupId"]})
    save_config({"team_groups": groups})
    click.echo(f"Added '{match['name']}' ({len(members)} members) to team_groups")


@team.command("remove")
@click.argument("group_name")
def team_remove(group_name: str):
    """Remove a group from team_groups config."""
    config = load_config()
    groups = config.get("team_groups", [])
    new_groups = [
        g for g in groups
        if (g["name"] if isinstance(g, dict) else g).lower() != group_name.lower()
    ]
    if len(new_groups) == len(groups):
        click.echo(f"Not configured: {group_name}")
        return
    save_config({"team_groups": new_groups})
    click.echo(f"Removed '{group_name}' from team_groups")


@team.command("show")
@click.option("-p", "--project", default=None, help="Project key (for fallback list)", shell_complete=_complete_project)
def team_show(project: str | None):
    """Show configured groups and their members."""
    config = load_config()
    groups = config.get("team_groups", [])
    client = make_client()
    project_key = get_project(project)

    try:
        if groups:
            names = [g["name"] if isinstance(g, dict) else g for g in groups]
            click.echo(f"Configured groups: {', '.join(names)}")
            click.echo()
            members = client.get_team_members(project_key)
        else:
            click.echo("No team_groups configured. Showing assignable users for " + project_key + ":")
            click.echo()
            members = client.get_assignable_users(project_key)

        for m in members:
            click.echo(f"  {m['displayName']}")
        click.echo(f"\n  {len(members)} members")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@cli.group()
def project():
    """Manage configured projects."""


@project.command("search")
@click.argument("query")
def project_search(query: str):
    """Search for JIRA projects."""
    client = make_client()
    try:
        projects = client.search_projects(query)
        if not projects:
            click.echo("No projects found.")
            return
        key_width = max(len(p["key"]) for p in projects)
        for p in projects:
            click.echo(f"  {p['key']:<{key_width}}  {p['name']}")
    except JiraApiError as e:
        raise click.ClickException(str(e))


@project.command("add")
@click.argument("project_key")
def project_add(project_key: str):
    """Add a project to the configured list."""
    client = make_client()
    # Validate project exists
    results = client.search_projects(project_key)
    match = None
    for p in results:
        if p["key"].upper() == project_key.upper():
            match = p
            break
    if not match:
        raise click.ClickException(
            f"Project '{project_key}' not found. Use 'ticket project search' to find it."
        )
    config = load_config()
    projects = config.get("projects", [])
    existing_keys = {p["key"] for p in projects}
    if match["key"] in existing_keys:
        click.echo(f"Already configured: {match['key']}")
        return
    projects.append({"key": match["key"], "name": match["name"]})
    save_config({"projects": projects})
    click.echo(f"Added {match['key']} ({match['name']})")
    # Set as default if it's the first project
    if len(projects) == 1:
        save_config({"default_project": match["key"]})
        click.echo("Set as default project")


@project.command("remove")
@click.argument("project_key")
def project_remove(project_key: str):
    """Remove a project from the configured list."""
    config = load_config()
    projects = config.get("projects", [])
    new_projects = [p for p in projects if p["key"].upper() != project_key.upper()]
    if len(new_projects) == len(projects):
        click.echo(f"Not configured: {project_key}")
        return
    save_config({"projects": new_projects})
    click.echo(f"Removed {project_key}")


@project.command("list")
def project_list():
    """Show configured projects."""
    config = load_config()
    projects = config.get("projects", [])
    default = get_project(None)
    if not projects:
        click.echo(f"No projects configured. Current default: {default}")
        return
    for p in projects:
        marker = " *" if p["key"] == default else ""
        click.echo(f"  {p['key']}  {p['name']}{marker}")


@project.command("default")
@click.argument("project_key")
def project_default(project_key: str):
    """Set the default project."""
    config = load_config()
    projects = config.get("projects", [])
    # Allow setting default even if not in configured list, but warn
    configured_keys = {p["key"].upper() for p in projects}
    if projects and project_key.upper() not in configured_keys:
        click.echo(f"Warning: {project_key} is not in your configured projects list")
    save_config({"default_project": project_key.upper()})
    click.echo(f"Default project set to {project_key.upper()}")


# ── Entry Point ─────────────────────────────────────────

if __name__ == "__main__":
    cli()
